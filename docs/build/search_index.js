var documenterSearchIndex = {"docs":
[{"location":"peel/#Peel.jl-Documentation","page":"Main functions","title":"Peel.jl Documentation","text":"","category":"section"},{"location":"peel/#Main-functions","page":"Main functions","title":"Main functions","text":"","category":"section"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"checkAndExtractSingleton","category":"page"},{"location":"peel/#Main.PEEL.checkAndExtractSingleton","page":"Main functions","title":"Main.PEEL.checkAndExtractSingleton","text":"checkAndExtractSingleton(indexes,BITS;cutoff=0.000002)\n\nArguments\n\nindexes: A list of arrays, being the bins and their offsets.\nBits: the number of bits (being 2*qubits)\ncutoff: what the entropy has to be less than\n\nChecks the 'entropy' in the bin (ie sum of the square of the fluctations around the mean of the abs value)/BITS If it is less than the cutoff admits it as a singleton. Extracts the Pauli (using majority vote if given multiple samples)\n\nNote if you wanted to implement the \"Error Correcting Code in the offsets\" as described in the appendix of the paper then this funciton would be different.\n\nReturns\n\nA tuple of: (found,index, value), where found is boolean, the index is an integer and value is float (between 0 and 1).\n\n\n\n\n\n","category":"function"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"PEEL.peelBack","category":"page"},{"location":"peel/#Main.PEEL.peelBack","page":"Main functions","title":"Main.PEEL.peelBack","text":"peelBack(listOfX,listOfPs,singletonBits,singletonValue,found,ds,mappings)\n\nArguments\n\nlistOfX - the bins and their offsets <- this gets modified\nlistOfPs - the stabiliser groups used to create the bins (see generateFromPVecSamples4N)\nsingletonBits - the bit index of the Pauli to peel back\nsingletonVlaue - the value of the Pauli to peel back\nfound - a Dict of Pauli bitstrings that have been found and their value\nds - the offsets used.\nmappings - an optional mapping of qubit->qubit.\n\nPeel back algorithm tailored for noise version.\n\nCheck if we have already found the supplied Pauli (is it in found?)\n\nIf so check if the value we think we have found is greater than the previous sample\nIf not, then just return - we had already found it, and the noise has just confused us!\nIf yes, then the one we found was probably wrong and a result of the noise, just update the value.\n\n[Query this logic, it seems to work but perhaps, we may want to update the bins with the difference.]\n\nOtherwise (i.e. we hadn't found it before.)\nGet the index of that Pauli into each of the other bin sets\nAnd add or subtract (depending on relevant offset) the supplied value of the Pauli\nUpdate found by adding in this Pauli and the value.\n\n\n\n\n\n","category":"function"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"generateFromPVecSamples4N","category":"page"},{"location":"peel/#Main.PEEL.generateFromPVecSamples4N","page":"Main functions","title":"Main.PEEL.generateFromPVecSamples4N","text":"generateFromPVecSamples4N(pvec,d=[],dictMapping)\n\nArguments\n\npvec The list of Paulis which are used in our experiment. Given as an array of stabilisers (see example)\nd The offset, this is the binary string 'hashed' into the Paulis given by pvec.\nmap an optional dictionary mapping qubits to other qubits.\n\nGenerates the fidelities we are going to sample from for a given offset  vector (d).\n\nBy way of example, if we supplied as a pvec\n\n[[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0]]\n\n\nThen we would get 0,7,9 and 14.\n\nIf we also suplied a d, [1 0 0 0], then we get 8, 15, 1 6\n\nA pvec as \n\n [[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0]]\n [[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0]]\n\nWould give us 0, 7, 9, 14, 112, 119, 121, 126, 144, 151, 153, 158, 224, 231, 233, 238\n\nReturns\n\nArray{Int64,1} with the relevant fidelity indexes. (zero indexed).\n\n\n\n\n\n","category":"function"},{"location":"peel/#Useful-functions","page":"Main functions","title":"Useful functions","text":"","category":"section"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"PEEL.fourPattern(n)","category":"page"},{"location":"peel/#Main.PEEL.fourPattern-Tuple{Any}","page":"Main functions","title":"Main.PEEL.fourPattern","text":"fourPattern(p)\n\nArguments\n\np::Array{Array{Array{Int64,1},1},1} represents a series of commuting two qubit paulis.\n\nGiven a MUB works out what binary string will go in what bin This takes a 4 bit (two Pauli) set of commuting Paulis, eg.\n\n1-element Array{Array{Array{Int64,1},1},1}:\n [[0, 0, 0, 0], [1, 0, 1, 1], [0, 1, 1, 0], [1, 1, 0, 1]]\n\nAnd then returns the Array that shows what bin each of the 16 two qubit Paulis go into e.g.\n\n[[[\"0000\", \"0111\", \"1001\", \"1110\"], [\"0001\", \"0110\", \"1000\", \"1111\"], [\"0011\", \"0100\", \"1010\", \"1101\"], [\"0010\", \"0101\", \"1011\", \"1100\"]]]\n\nWhich tells us e.g. that \"1001\" goes into bin 0 and \"1101\" goes into bin 2.\n\nReturns\n\nan Array, containing a single array of 4 vectors each of size 4 --- splitting all 16 Paulis (rep as binary strings) into 4 bins.\n\nIf you want to think of this as a hashing function, it shows how to take 4 bits -> 2 bits using the supplied pattern.\n\n\n\n\n\n","category":"method"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"twoPattern(n)","category":"page"},{"location":"peel/#Main.PEEL.twoPattern-Tuple{Any}","page":"Main functions","title":"Main.PEEL.twoPattern","text":"twoPattern(p)\n\nArguments\n\n p Array{Array{Int64,1},1} represents a series of commuting two qubit paulis.\n\nGiven a MUB works out what binary string will go in what bin This takes a 2 bit (one Pauli) set of commuting Paulis, eg.\n\n1-element Array{Array{Array{Int64,1},1},1}:\n [0, 0], [1, 1]\n\nAnd then returns a two element Array that shows what bin each of the 16 two qubit Paulis go into e.g.\n\n[\"00\", \"11\"]\n[\"01\", \"10\"]\n\nWhich tells us e.g. that \"11\" goes into bin 0 and \"01\" goes into bin 2.\n\nReturns\n\nan Array, containing an array of 2 vectors each of size 2 --- splitting all 4 Paulis (rep as binary strings) into 2 bins.\n\nIf you want to think of this as a hashing function, it shows how to take 2 bits -> 1 bits using the supplied pattern.\n\n\n\n\n\n","category":"method"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"getIndexOf","category":"page"},{"location":"peel/#Main.PEEL.getIndexOf","page":"Main functions","title":"Main.PEEL.getIndexOf","text":"getIndexOf(hadamardMap,no,dictMap=Dict())\n\nArguments\n\nhadamardMap: An array of hashing bins (see later)\nno: Integer  the index of the Pauli we want to know which bin it gotes into \ndictMap: Dictionary optional mapping eg qubit 2->qubit 4.\n\nGiven a map (constructed from fourPattern and twoPattern), this will  split the qubits up into the pairs/singles identified by the map and  then determine the hash destingation of a particular Pauli, i.e. which bin it goes into.  The optional dictMapping, allows us to map qubits to different qubits. This might be   relevant for different topologies. E.g. we might want the pair to span qubits 1 and 14, rather  than 1 and 2, so we would map 2 onto 14. There should be examples later.\n\nNOTE because we use the least significant (rh) qubit - there is a subte reversal of bits. See example.\n\nExample\n\nThe hadamard Map for a six qubit system might look like this\n\n4-element Array{Any,1}:\n [[\"00\", \"10\"], [\"01\", \"11\"]]\n [[\"0000\", \"0110\", \"1101\", \"1011\"], [\"1100\", \"1010\", \"0001\", \"0111\"], [\"1000\", \"1110\", \"0101\", \"0011\"], [\"0100\", \"0010\", \"1001\", \"1111\"]]\n [[\"0000\", \"1110\", \"1001\", \"0111\"], [\"1100\", \"0010\", \"0101\", \"1011\"], [\"0100\", \"1010\", \"1101\", \"0011\"], [\"1000\", \"0110\", \"0001\", \"1111\"]]\n [[\"00\", \"01\"], [\"10\", \"11\"]]\n\nWhere we have used twoPattern for qubits 0 and 5 and fourPattern for qubits 1&2 and 3&4\n\ngetIndexOf(patternAbove, 23), would then return 6.\n\nBecause 23 = \"000000010111\"  Then we map the bins as   00-> reversed to 00 -> bin 0 -> 0  0000 -> reversed to 0000 ->  bin 0 -> 00  0101 -> reversed to 1010 ->  bin 2 -> 10  11 ->  reversed to 11 -> bin 1 -> 01\n\nTherefore the index is 0 00 10 01 = 5, as we one index we return 6.\n\nReturns\n\nIndex of bin (1 indexed).\n\n\n\n\n\n","category":"function"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"constructTheKeyIndexMUB","category":"page"},{"location":"peel/#Main.PEEL.constructTheKeyIndexMUB","page":"Main functions","title":"Main.PEEL.constructTheKeyIndexMUB","text":"constructTheKeyIndexMUB(indx,listOfPs,map=[])\n\nArguments\n\nindx The index of a Pauli, we want to ascertain which bins that Pauli was hashed into.\nlistOfPs The used to sample/bin the Paulis\nmap A map of qubit substitutions e.g mapping qubit 2 to 14\n\nGiven a Paulis to test, returns the index into all the bins that Paulis is hashed into  (it is assumed we have a number a sub-sampling groups). Basically just iterates over them. If we supply a map, it should be an array of maps, one for each different set of n-qubit MUBS supplied.\n\nIt uses getIndexOf to do all the heavy lifting, the documentation for that function  provides an example of the type of map it requires, this is an array of these maps.\n\nReturns and array of offsets representing the index the Pauli gets hashed to.\n\n\n\n\n\n","category":"function"},{"location":"peel/#Manipulation-of-probability-vectors","page":"Main functions","title":"Manipulation of probability vectors","text":"","category":"section"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"simplexUp","category":"page"},{"location":"peel/#Main.PEEL.simplexUp","page":"Main functions","title":"Main.PEEL.simplexUp","text":"simplexUp(n)\n\nArguments\n\nn (Int)  = number to project onto \n\nProjects onto the n-simplex. i.e. returns n numbers such that the sum of them is 1.\n\nReturns\n\nvector of n-numbers that add up to 1.\n\n\n\n\n\n","category":"function"},{"location":"peel/","page":"Main functions","title":"Main functions","text":"generatePauliFromClifford","category":"page"},{"location":"peel/#Main.PEEL.generatePauliFromClifford","page":"Main functions","title":"Main.PEEL.generatePauliFromClifford","text":"generatePauliFromClifford(n)\n\nArguments\n\ncliffordPs: Array{Float64,1}\n\nSplits the \"Clifford average\" which we recover from the protocol in Efficient Learning of quantum Noise arXiv:1907.13022. into  a fake Pauli distribution, that would average to the same Clifford average. We are going to use this to test the algorithm.\n\nWe do this by realising that each member of our 2^n distribution was in fact an average of certain Paulis. We work out how many Paulis went into the distribution (splitUp(n)) and then project the number onto an appropriate simplex (simplexUp).\n\nThis allows us to recreate a 4^n distribution that would average down to the supplied distribution. Of course there is a random  element with the projection up stage, but it is experimentally inspired if the original averaged protocol came from an experiment.\n\nReturns\n\nA Pauli probability distribution that result in the supplied probability distribution if they were the errors caused by the  avarged noise in the machine and that machine was subject to single qubit Clifford twirls.\n\n\n\n\n\n","category":"function"},{"location":"#Scalable-Estimation-Documentation","page":"Introduction","title":"Scalable Estimation Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"peel.md\", \"localPeel.md\"]\nDepth = 2","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of the code used to implement the algorithm discussed in the paper Fast estimation of sparse quantum noise by Harper, Yu and Flammia (in production).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are a number of IJulia workbooks that accompany this code that detail the use of the software and the implementation of the algorithm. They are detailed in the section Example workbooks.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Figure) Figure 1 from the paper, shows the type of recovery that is possible using the code and cicuits discussed here","category":"page"},{"location":"#Scalable-Estimation","page":"Introduction","title":"Scalable Estimation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main workbook uses data taken from the IBM Quantum Experience (Melbourne device, when it only had 14 qubits), uses that to create a full Pauli distribution and then attempts to reconstruct the distribution from limited sampling of the eigenvalues corrupted by varying levels of noise. It contains the code, analysis and figures that appear in the paper. It does, however, assume a certain level of knowledge which is the point of the workbooks also contained in this repository","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It implicilty uses the algorithm detailed in Efficient Learning of quantum Noise arXiv:1907.13022 , code for which is located at https://github.com/rharper2/Juqst.jl. Python code to run such experiments on the IBM Quantum Experience (using qiskit) can be found on https://github.com/rharper2/query_ibmq.","category":"page"},{"location":"#Overview-of-the-steps-required","page":"Introduction","title":"Overview of the steps required","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The workbooks contains examples showing all the steps necessary, but it might be helpful here for me to cover the basics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The actual algorithm, assumes an eigenvalue oracle, but here we also show how to construct such an oracle in practice. The following picture might help, the left hand-side of the picture might be though of as the recovery algorithm, the right hand side is the sub-sampling algorithm - i.e. the procedure to create the 'eigenvalue' oracle.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Figure)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"On a practical level the first thought might be how do I sable the eigenvalues of the averaged noise channel of my device. The algorithms here are a variation of randomised benchmarking and the concepts behind them are detailed in two papers arXiv:1907.13022 and arxiv:1907.12976. Basically this allows us to recover upto 2^n commuting eigenvalues 'per' experiment, where n is the number of qubits in the machine. To recover an arbitrary set of commuting eigenvalues in an experiment would require the ability to create n-qubit Clifford gates, which is probably impractical. The first step then is to create an ansatz where we can design an experiment that recovers the Pauli eigenvalues we need using only two local gates.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The Local stabiliser part of the package is designed to make this easy. The workbook Scalable Estimation - Experimental Qiskit- Just 3 qubits Web friendly version, shows how to do this all in qiskit for a small system - easily expandable. The functions to look at include generateSensibleSubsamples, where if you give it your two qubit connectivity will suggest the type of sub samples you might need and the appropriately named getCircuit which takes the output of the previous function and generates a circuit of the depth you want. Like randomised benchmarking we use a number of runs at varying 'depths' to generate a decay curve. It's just that we generate 2^n decay curves!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Note if all the above means little to you, there are a couple of other introductory workbooks that may prove helpful.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Two such experiments as described above, will begin to fill in the 'oracle', i.e. we now have the bins that appear on the right hand side of the bi-partite graph in the diagram above. However, we still need to be able to answer the questions \"Is there a single Pauli of weight in the bin (red in the diagram)?\" and \"If so - which Pauli is it\".  Currently the only way we have to do this is to generate 'offset' eigenvalues. (The paper explains this in detail). So how do we generate these? Well basically for every two qubit groups there are 5 different type of local variation (and we have already done one of them). We just need to cycle through the qubit pairs and do the other 4. You can see how this is done in the various workbooks using the code, but basically in very bad pseudo code it is this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For pair in QubitPairs:\n\tFor experimentType in 1..5:\n\t\tif not we have already done that experiment type on pair: \n\t\t   do the experiment, with with experimentType on pair, and add the eigenvalues to the oracle.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"So each pair of qubits will have require a further 4 expements, giving us a total of 2n new experiments per sub-sampling group. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once we have that we have our eigenvalue oracle and we have generated our bins, then its then just a question of iteratively going through the bins. We ask \"is there a single Pauli in there?\". If there is we have the value of that Pauli error. When we identify a Pauli we can see if it is part of a bin containing other Paulis and substract it out (we call this peeling). So for instance, in the diagram above - in Group 2 you can see that Pauli IY is sitting alone in a bin. We can then find its value and subtract it from bin 3 in Group 1. When we do that there is only one Pauli in that bin (Pauli XY) and so we also get that one!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The code is, like a lot of code, slightly fiddly - but I have done my best to set it out in the example workbooks. The easiest way to understand that is to look at the noiseless example first Scalable Estimation-Basic Concepts.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Copyright: Robin Harper 2019-2020","category":"page"},{"location":"localPeel/#Additional-local-Peel-Functions","page":"Local stabiliser functions","title":"Additional local Peel Functions","text":"","category":"section"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"You need to include \"localPeelFunctions.jl\" to access these. Assumes qiskit is enabled in your Julia set up.","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"I believe the easiest way to make qiskit available is as follows:","category":"page"},{"location":"localPeel/#To-get-qiskit-under-Julia","page":"Local stabiliser functions","title":"To get qiskit - under Julia","text":"","category":"section"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"You will need to install Conda, PyCall using the julia package manager.","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"Easiest way is the repl (hit ], then add Conda, add PyCall) or...","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"using Pkg\nPkg.add(\"Conda\")\nPkg.add(\"PyCall\")","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"then use Conda to install pip","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"using Conda\nConda.add(\"pip\")","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"Once that is done, then we can use pip to install qiskit.","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"using PyCall\nrun(`$(PyCall.pyprogramname) -m pip install qiskit`)","category":"page"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"Then we can use qiskit from Julia!","category":"page"},{"location":"localPeel/#Main-user-functions","page":"Local stabiliser functions","title":"Main user functions","text":"","category":"section"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"generateSensibleSubsamples","category":"page"},{"location":"localPeel/#generateSensibleSubsamples","page":"Local stabiliser functions","title":"generateSensibleSubsamples","text":"generateSensibleSubsamples(experiments)\n\nArguments\n\nexperiments: A list of tuples, showing how to locally divide the qubits.\n\nEach experiment needs to be for the same number of qubits.\n\nExample\n\nIf you pass in [(2,2,2),(1,2,2,1)] Then this would generage the needed data for two expeiments, each for 6 qubits.\n\nThe first would use two qubit gates on qubits 0&1, 2&3 and 4&5.\nThe second would use single qubit gates on qubits 0 and 5, and two qubit gates on 1&2 and 3&4.\n\nWith three qubits, we might call it thus:\n\n(experiments,paulisAll,ds) = generateSensibleSubsamples([(2,1),(1,2)])\nprint(\"$experiments\\n\")\nprint(\"$paulisAll\\n\")\n\nAny[Any[(2, 1), (1, 1)], Any[(1, 3), (2, 2)]]\nAny[Any[[[0, 0, 0, 0], [1, 1, 0, 1], [1, 0, 1, 1], [0, 1, 1, 0]], [[0, 0], [0, 1]]], Any[[[0, 0], [1, 1]], [[0, 0, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 0, 1]]]]\n\nThe Experiment numbers are defined like this:\n\npotentialSingles = [\n                    [[0,0],[0,1]], # IX\n                    [[0,0],[1,0]], # IY\n                    [[0,0],[1,1]], # IZ\n                    ]\n\n\nall2QlMuBs =  [  [[0,0,0,0],[1,1,0,1],[1,0,1,1],[0,1,1,0]], #II ZX YZ XY\n                 [[0,0,0,0],[1,1,1,0],[0,1,1,1],[1,0,0,1]], #II ZY XZ YX\n                 [[0,0,0,0],[0,0,0,1],[0,1,0,0],[0,1,0,1]], #II IX XI XX\n                 [[0,0,0,0],[0,0,1,0],[1,0,0,0],[1,0,1,0]], #II IY YI YY\n                 [[0,0,0,0],[0,0,1,1],[1,1,0,0],[1,1,1,1]]] #II IZ ZI ZZ\n\nReturns\n\nThe following tuple (chosenExperiments, chosenPaulis, ds), where\n\nchosenExperiments is a list of experiment list, where each experiment list contains a tuple of qubit size and experiment number.\nchosenPaulis are the Paulis that will be generated by each tuple in an experiment list (using the 01->X 10->Y 11->Z mapping) \nds is just a convenient bit-array of offsets of 2*noOfQubits, used in working out offsets for the decoder.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"getCircuit","category":"page"},{"location":"localPeel/#getCircuit","page":"Local stabiliser functions","title":"getCircuit","text":"getCircuit(experiment,noOfGates)\n\nArguments\n\nexperiment: a list of tuples (such as that obtained from generateSensibleSubsamples)\nnoOfGates: the number of Paulis we want in the middle (to twirl)\n\nGenerates a qiskit circuit that implements the experiment passed in (e.g [(2,1) (2,2)] will generate a cricuit that uses two 2 qubit MUBS at the beginning and end (1 and 2 respectively) and then performs a Pauli Twirl in the middle). The circuits are self-inverting.\n\nAppropriate barriers are inserted.\n\nExample\n\n(experiments,paulisAll,ds) = generateSensibleSubsamples([(2,1),(1,2)]) # Get some experiments\ncircuit = getCircuit(experiments[1],12) # twelve pauli twirl circuit.\nqiskit.execute(circuit,qiskit.Aer.get_backend(\"qasm_simulator\"),shots=100).result().get_counts() # noisless simulator.\ncircuit.draw() # Will draw the circuit\n\nReturns\n\nthe qiskit circuit.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"doASeries","category":"page"},{"location":"localPeel/#doASeries","page":"Local stabiliser functions","title":"doASeries","text":"doASeries(experiment,lengths,sequences,shots,noise_mode)\n\nArguments\n\nexperiment - the experiment to perform (see getCircuit for detailed explanation)\nlengths - a list of the lengths to perform the experiment on.\nsequences - the number of randomised sequences to perform at each length.\nshots - the number of measurements of each sequences\nnoise-model - the noise model you want passed to the 'Aer' simulator.\n\nA convenience function to simulate the basic information gathering algorithm. We assume a an Aer simulator, and you supply the noise model. For edifferent simulators or to run on a real device you will have to re-implement this function, probably just change the execute line.\n\nReturns\n\na list of the a list of the results of each sequence.(ordered by the same way as lengths).\n\nNote on a real device you probably want to randomise the order that different lengths are called i.e. don't do all the short ones, slightly longer and then longer ones in a row.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"getCounts","category":"page"},{"location":"localPeel/#getCounts","page":"Local stabiliser functions","title":"getCounts","text":"getCounts(results,lengths,noOfQubtis)\n\nConvenience funciton that takes the results from doASeries and consolidates the counts accross different sequences i.e. if we have 10 sequences at lengths 10,20 and 40, groups all the sequences at length 10 together, the seqeunces at length 20 ... etc. It then transforms into a probability vector (i.e. the vector for each length by the total number of counts).\n\nNOTE: we assume that the machine is able to handle a vector of size 2^noOfQubits\n\nReturns\n\nA list of probability vectors, one for each length.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"extractEigenvalues","category":"page"},{"location":"localPeel/#extractEigenvalues","page":"Local stabiliser functions","title":"extractEigenvalues","text":"extractEigenvalues(counts,lengths)\n\nUses the functionality of Juqst - quantumNoise algorithms to extract the eigenvalues from a vector of counts. For documentation on fitTheFidelities, see rharper2/Juqst.jl on gitHub. To see how the counts should look see getCounts or the example workbooks.\n\nReturns\n\nthe Eigenvalues for the supplied probability vector.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"generateEigenvalues","category":"page"},{"location":"localPeel/#generateEigenvalues","page":"Local stabiliser functions","title":"generateEigenvalues","text":"generateEigenvalues(stabs)\n\nArguments\n\nstabs - a list of the Paulis used in the experiment, this can be obtained from the generateSensibleSubsamples function.\n\nUses a recursive algorithm to work out which global eigenvalues will be learnt through the supplied Paulis/experiment. You can use PEEL.fidelityLabels(ix-1) to see the Pauli representation of these eigenvalues. Note the need to subtract 1, to mvoe from Julia 1 index to a 0 index label (i.e. in Julia II...I is 1, whereas fidelityLabels expects this to be 0).\n\nReturns\n\na list of eigenvalues (Julia 1 indexed).\n\n\n\n\n\n","category":"function"},{"location":"localPeel/#More-down-in-the-weeds","page":"Local stabiliser functions","title":"More down in the weeds","text":"","category":"section"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"addCircuit","category":"page"},{"location":"localPeel/#addCircuit","page":"Local stabiliser functions","title":"addCircuit","text":"addCircuit(circuit,experimenttype,qubitsid)\n\nArguments\n\ncircuit - the qiskit circuit we will add gates to.    experiment-type: (Integer,Integer) - the stabilizer group we wont to generate (see below)    qubits_id: Array of Int - the 'number' of the qubits the circuit is to be on.\n\nThe stabilizer circuits vary depending on the experiment-type. This is a tuple, the first number indicating the number of  qubits (currently 1 or 2), the second which experiment currently 1:3 for single qubits and 1:5 for two qubits.\n\nThe qubits_id will be used to work out which qubits in the circuit to use. They are \"JULIA INDEXED\".\n\nThe qubits are identified via the circuit qubits = circuit.qubits. But because of the way PyCall works, they will be  in a 1 indexed array. e.g. qiskitits qubit_0 will be qubits[1].\n\nTherefore if you want the circuit to be on qubits 0 and 1, you pass in [1,2] into qubits_id.\n\nThe circuits that will be added will generate the following for two qubits its:\n\n[[0,0,0,0],[1,1,0,1],[1,0,1,1],[0,1,1,0]], #II ZX YZ XY\n[[0,0,0,0],[1,1,1,0],[0,1,1,1],[1,0,0,1]], #II ZY XZ YX\n[[0,0,0,0],[0,0,0,1],[0,1,0,0],[0,1,0,1]], #II IX XI XX\n[[0,0,0,0],[0,0,1,0],[1,0,0,0],[1,0,1,0]], #II IY YI YY\n[[0,0,0,0],[0,0,1,1],[1,1,0,0],[1,1,1,1]]] #II IZ ZI ZZ\n\nFor one qubit its\n\n[[0,0],[0,1]], # IX\n[[0,0],[1,0]], # IY\n[[0,0],[1,1]], # IZ\n\nReturns nothing\n\nThe qiskit circuit will have had the gates added.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"addReverseCircuit","category":"page"},{"location":"localPeel/#addReverseCircuit","page":"Local stabiliser functions","title":"addReverseCircuit","text":"addReverseCircuit(circuit,experimenttype,qubitsid)\n\nArguments\n\ncircuit - the qiskit circuit we will add gates to.    experiment-type: (Integer,Integer) - the stabilizer group we wont to generate (see below)    qubits_id: Array of Int - the 'number' of the qubits the circuit is to be on.\n\nEffectively this 'reverses' the circuit added by addCircuit. \n\ne.g. \n\naddCircuit(my_circuit,(2,1),[1,2])\naddReverseCircuit(my_circuit,(2,1),[1,2,])\n\nWill create a 'nothing' circuit i.e. self inverting.\n\nThe stabilizer circuits vary depending on the experiment-type. This is a tuple, the first number indicating the number of  qubits (currently 1 or 2), the second which experiment currently 1:3 for single qubits and 1:5 for two qubits.\n\nThe qubits_id will be used to work out which qubits in the circuit to use. They are \"JULIA INDEXED\".\n\nThe qubits are identified via the circuit qubits = circuit.qubits. But because of the way PyCall works, they will be  in a 1 indexed array. e.g. qiskitits qubit_0 will be qubits[1].\n\nTherefore if you want the circuit to be on qubits 0 and 1, you pass in [1,2] into qubits_id.\n\nThe circuits that will be added will generate the following for two qubits its:\n\n[[0,0,0,0],[1,1,0,1],[1,0,1,1],[0,1,1,0]], #II ZX YZ XY\n[[0,0,0,0],[1,1,1,0],[0,1,1,1],[1,0,0,1]], #II ZY XZ YX\n[[0,0,0,0],[0,0,0,1],[0,1,0,0],[0,1,0,1]], #II IX XI XX\n[[0,0,0,0],[0,0,1,0],[1,0,0,0],[1,0,1,0]], #II IY YI YY\n[[0,0,0,0],[0,0,1,1],[1,1,0,0],[1,1,1,1]]] #II IZ ZI ZZ\n\nFor one qubit its\n\n[[0,0],[0,1]], # IX\n[[0,0],[1,0]], # IY\n[[0,0],[1,1]], # IZ\n\nReturns nothing\n\nThe qiskit circuit will have had the gates added.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"setUpExperiment","category":"page"},{"location":"localPeel/#setUpExperiment","page":"Local stabiliser functions","title":"setUpExperiment","text":"setUpExperiment(experiment,circuit;reverse=false)\n\nArguments\n\nexperiment: List of tuples - the stabilizers to be extracted\ncircuit: circuit to be done\nreverse: apply or removing? Boolean.\n\nCycles through the experiment applying the correct gates in the circuit. The experiment is set up as a list of tuples (qno,expno), representing the number of qubits (currently 1 or 2) and the type of experiment.\n\nFor example [(1,3),(2,1),(2,3)] would be a 5 qubit experiment.\n\nThe 1 qubit experiment 3 would be applied to the first qubit.\nThe 2 qubit experiment 1 would be applied to the second and third qubits\nThe 2 qubit experiment 3 would be applied to the fourth and fifth qubits.\n\nReturns\n\nNothing, but amends the supplied circuit.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"genPTwirl","category":"page"},{"location":"localPeel/#genPTwirl","page":"Local stabiliser functions","title":"genPTwirl","text":"genPTwirl(circuit,len,qubit_id)\n\ngenerates a Pauli twirl on the circuit consisting of len gates + inversion gate. On qubit_id\n\nArguments\n\ncircuit - the qiskit circuit to alter\nlen - an integer representing the number of gates in the twirl\nqubit_id - an integer representing the qubit. Index from 1 (Julia), the qubit register is retrieved from circuit and is not needed.\n\nReturns\n\nNothing - the circuit is altered.\n\n\n\n\n\n","category":"function"},{"location":"localPeel/","page":"Local stabiliser functions","title":"Local stabiliser functions","text":"getStabilizerForExperiment","category":"page"},{"location":"localPeel/#getStabilizerForExperiment","page":"Local stabiliser functions","title":"getStabilizerForExperiment","text":"getStabiliserForExperiment(experiment)\n\nFor a given experiment (see generateSensibleSubsamples)  returns the Paulis (in bit form) that are accessed via the experiment.\n\n\n\n\n\n","category":"function"},{"location":"example/#Example-workbooks","page":"Example Workbooks","title":"Example workbooks","text":"","category":"section"},{"location":"example/","page":"Example Workbooks","title":"Example Workbooks","text":"Below are links to rendered versions of the example workbooks contained in the repository (if you want to run them clone the repo!):","category":"page"},{"location":"example/","page":"Example Workbooks","title":"Example Workbooks","text":"ScalableEstimation.ipynb. This is the main workbook that reproduces all the diagrams and charts in the paper. It assumes some knowledge of the algorithm and uses experimental data as the basis for the distribution it recreates. Web friendly version.\nHadamard Basics and Observations.ipynb. A work book setting out some of the basic concepts behind the Walsh-Hadamard transform, the global probability vector and the SuperOperator (Pauli basis) Eigenvalues and measurements (observations). If you are a bit unclear on these terms, this might be a good place to start. Web friendly version.\nScalable Estimation - Basic Concepts.ipynb. This is a small qubit, no noise work through of the protocol. If you are a bit unclear on some of the more basic concepts, this aims to cover those. Web friendly version.\nScalable Estimation - Experimental Basics.ipynb. This shows how to create the circuits needed to get the eigenvalues to run the protocol. Because of the limitations of the simulaton it is only for 6 qubits, which are too few to justify the protocol. The workbook is long and contains a wealth of data output - if you are trying to write your own version of the protocol this will be a useful tool to debug. If you just want to learn how to run appropriate circuits, the qiskit workbooks (below) are probably a better bet. Web friendly version.\nScalable Estimation - Experimental Qiskit- Just 3 qubits.ipynb. This shows how to create, run and the circuits and the peel the results using qiskit and the AER simulator. It is only 3 qubits, so not the size this is aimed at, but the simulation runs quite fast! It may be helpful to see how to do it on your bigger system. Web friendly version.","category":"page"}]
}
