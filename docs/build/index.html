<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Scalable Estimation Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Scalable Estimation Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Scalable-Estimation"><span>Scalable Estimation</span></a></li><li><a class="tocitem" href="#Overview-of-the-steps-required"><span>Overview of the steps required</span></a></li></ul></li><li><span class="tocitem">Code</span><ul><li><a class="tocitem" href="peel/">Main functions</a></li><li><a class="tocitem" href="localPeel/">Local stabiliser functions</a></li></ul></li><li><a class="tocitem" href="example/">Example Workbooks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rharper2/sparsePauliReconstruction/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Scalable-Estimation-Documentation"><a class="docs-heading-anchor" href="#Scalable-Estimation-Documentation">Scalable Estimation Documentation</a><a id="Scalable-Estimation-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Scalable-Estimation-Documentation" title="Permalink"></a></h1><ul><li><a href="peel/#Peel.jl-Documentation">Peel.jl Documentation</a></li><ul><li><a href="peel/#Main-functions">Main functions</a></li><li><a href="peel/#Useful-functions">Useful functions</a></li><li><a href="peel/#Manipulation-of-probability-vectors">Manipulation of probability vectors</a></li></ul><li><a href="localPeel/#Additional-local-Peel-Functions">Additional local Peel Functions</a></li><ul><li><a href="localPeel/#Main-user-functions">Main user functions</a></li><li><a href="localPeel/#More-down-in-the-weeds">More down in the weeds</a></li></ul></ul><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>This is the documentation of the code used to implement the algorithm discussed in the paper <strong>Fast estimation of sparse quantum noise</strong> by <em>Harper, Yu and Flammia</em> (in production).</p><p>There are a number of IJulia workbooks that accompany this code that detail the use of the software and the implementation of the algorithm. They are detailed in the section <a href="example/#Example-workbooks">Example workbooks</a>.</p><p><img src="figure1.png" alt="Figure"/> Figure 1 from the paper, shows the type of recovery that is possible using the code and cicuits discussed here</p><h2 id="Scalable-Estimation"><a class="docs-heading-anchor" href="#Scalable-Estimation">Scalable Estimation</a><a id="Scalable-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Scalable-Estimation" title="Permalink"></a></h2><p>The main workbook uses data taken from the IBM Quantum Experience (Melbourne device, when it only had 14 qubits), uses that to create a full Pauli distribution and then attempts to reconstruct the distribution from limited sampling of the eigenvalues corrupted by varying levels of noise. It contains the code, analysis and figures that appear in the paper. It does, however, assume a certain level of knowledge which is the point of the workbooks also contained in this repository</p><p>It implicilty uses the algorithm detailed in <strong>Efficient Learning of quantum Noise</strong> <a href="https://arxiv.org/abs/1907.13022">arXiv:1907.13022</a> , code for which is located at <a href="https://github.com/rharper2/Juqst.jl">https://github.com/rharper2/Juqst.jl</a>. Python code to run such experiments on the IBM Quantum Experience (using qiskit) can be found on <a href="https://github.com/rharper2/query_ibmq">https://github.com/rharper2/query_ibmq</a>.</p><h2 id="Overview-of-the-steps-required"><a class="docs-heading-anchor" href="#Overview-of-the-steps-required">Overview of the steps required</a><a id="Overview-of-the-steps-required-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-the-steps-required" title="Permalink"></a></h2><p>The workbooks contains examples showing all the steps necessary, but it might be helpful here for me to cover the basics.</p><p>The actual algorithm, assumes an eigenvalue oracle, but here we also show how to construct such an oracle in practice. The following picture might help, the left hand-side of the picture might be though of as the recovery algorithm, the right hand side is the sub-sampling algorithm - i.e. the procedure to create the &#39;eigenvalue&#39; oracle.</p><p><img src="bipartite.png" alt="Figure"/></p><p>On a practical level the first thought might be how do I sable the eigenvalues of the averaged noise channel of my device. The algorithms here are a variation of randomised benchmarking and the concepts behind them are detailed in two papers <a href="https://arxiv.org/abs/1907.13022">arXiv:1907.13022</a> and <a href="https://arxiv.org/abs/1907.12976">arxiv:1907.12976</a>. Basically this allows us to recover upto <span>$2^n$</span> commuting eigenvalues &#39;per&#39; experiment, where <span>$n$</span> is the number of qubits in the machine. To recover an arbitrary set of commuting eigenvalues in an experiment would require the ability to create <span>$n$</span>-qubit Clifford gates, which is probably impractical. The first step then is to create an ansatz where we can design an experiment that recovers the Pauli eigenvalues we need using only two local gates.</p><p>The Local stabiliser part of the package is designed to make this easy. The workbook Scalable Estimation - Experimental Qiskit- Just 3 qubits <a href="renderedWorkbooks/Scalable Estimation - Experimental Qiskit- Just 3 qubits.html">Web friendly version</a>, shows how to do this all in qiskit for a small system - easily expandable. The functions to look at include <a href="localPeel/#generateSensibleSubsamples"><code>generateSensibleSubsamples</code></a>, where if you give it your two qubit connectivity will suggest the type of sub samples you might need and the appropriately named <a href="localPeel/#getCircuit"><code>getCircuit</code></a> which takes the output of the previous function and generates a circuit of the depth you want. Like randomised benchmarking we use a number of runs at varying &#39;depths&#39; to generate a decay curve. It&#39;s just that we generate <span>$2^n$</span> decay curves!</p><p>(Note if all the above means little to you, there are a couple of other introductory workbooks that may prove helpful.)</p><p>Two such experiments as described above, will begin to fill in the &#39;oracle&#39;, i.e. we now have the bins that appear on the right hand side of the bi-partite graph in the diagram above. However, we still need to be able to answer the questions &quot;Is there a single Pauli of weight in the bin (red in the diagram)?&quot; and &quot;If so - which Pauli is it&quot;.  Currently the only way we have to do this is to generate &#39;offset&#39; eigenvalues. (The paper explains this in detail). So how do we generate these? Well basically for every two qubit groups there are 5 different type of local variation (and we have already done one of them). We just need to cycle through the qubit pairs and do the other 4. You can see how this is done in the various workbooks using the code, but basically in <em>very bad</em> pseudo code it is this:</p><pre><code class="language-none">For pair in QubitPairs:
	For experimentType in 1..5:
		if not we have already done that experiment type on pair: 
		   do the experiment, with with experimentType on pair, and add the eigenvalues to the oracle.</code></pre><p>So each pair of qubits will have require a further 4 expements, giving us a total of <span>$2n$</span> new experiments per sub-sampling group. </p><p>Once we have that we have our eigenvalue oracle and we have generated our bins, then its then just a question of iteratively going through the bins. We ask &quot;is there a single Pauli in there?&quot;. If there is we have the value of that Pauli error. When we identify a Pauli we can see if it is part of a bin containing other Paulis and substract it out (we call this peeling). So for instance, in the diagram above - in Group 2 you can see that Pauli <span>$IY$</span> is sitting alone in a bin. We can then find its value and subtract it from bin 3 in Group 1. When we do that there is only one Pauli in that bin (Pauli <span>$XY$</span>) and so we also get that one!</p><p>The code is, like a lot of code, slightly fiddly - but I have done my best to set it out in the example workbooks. The easiest way to understand that is to look at the noiseless example first <a href="renderedWorkbooks/Scalable Estimation - Basic Concepts.html">Scalable Estimation-Basic Concepts</a>.</p><p>Copyright: Robin Harper 2019-2020</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="peel/">Main functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 16 July 2020 14:43">Thursday 16 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
