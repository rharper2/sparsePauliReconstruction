<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Additional local Peel Functions · Scalable Estimation Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Scalable Estimation Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Scalable Estimation Documentation</a></li><li class="is-active"><a class="tocitem" href>Additional local Peel Functions</a><ul class="internal"><li><a class="tocitem" href="#Main-user-functions"><span>Main user functions</span></a></li><li><a class="tocitem" href="#More-down-in-the-weeds"><span>More down in the weeds</span></a></li></ul></li><li><a class="tocitem" href="../peel/">Peel.jl Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Additional local Peel Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Additional local Peel Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rharper2/sparsePauliReconstruction/blob/master/docs/src/localPeel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Additional-local-Peel-Functions"><a class="docs-heading-anchor" href="#Additional-local-Peel-Functions">Additional local Peel Functions</a><a id="Additional-local-Peel-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-local-Peel-Functions" title="Permalink"></a></h1><p>You need to include &quot;localPeelFunctions.jl&quot; to access these. Assumes qiskit is enabled in your Julia set up.</p><p>I believe the easiest way to make qiskit available is as follows:</p><h3 id="To-get-qiskit-under-Julia"><a class="docs-heading-anchor" href="#To-get-qiskit-under-Julia">To get qiskit - under Julia</a><a id="To-get-qiskit-under-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#To-get-qiskit-under-Julia" title="Permalink"></a></h3><p>You will need to install Conda, PyCall using the julia package manager.</p><p>Easiest way is the repl (hit ], then add Conda, add PyCall) or...</p><pre><code class="language-none">using Pkg
Pkg.add(&quot;Conda&quot;)
Pkg.add(&quot;PyCall&quot;)</code></pre><p>then use Conda to install pip</p><pre><code class="language-none">using Conda
Conda.add(&quot;pip&quot;)</code></pre><p>Once that is done, then we can use pip to install qiskit.</p><pre><code class="language-none">using PyCall
run(`$(PyCall.pyprogramname) -m pip install qiskit`)</code></pre><p>Then we can use qiskit from Julia!</p><h2 id="Main-user-functions"><a class="docs-heading-anchor" href="#Main-user-functions">Main user functions</a><a id="Main-user-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-user-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="generateSensibleSubsamples" href="#generateSensibleSubsamples"><code>generateSensibleSubsamples</code></a> — <span class="docstring-category">Function</span></header><section><div><p>generateSensibleSubsamples(experiments)</p><p><strong>Arguments</strong></p><pre><code class="language-none">experiments: A list of tuples, showing how to locally divide the qubits.</code></pre><p>Each experiment needs to be for the same number of qubits.</p><p><strong>Example</strong></p><p>If you pass in [(2,2,2),(1,2,2,1)] Then this would generage the needed data for two expeiments, each for 6 qubits.</p><ul><li>The first would use two qubit gates on qubits 0&amp;1, 2&amp;3 and 4&amp;5.</li><li>The second would use single qubit gates on qubits 0 and 5, and two qubit gates on 1&amp;2 and 3&amp;4.</li></ul><p>With three qubits, we might call it thus:</p><pre><code class="language-none">(experiments,paulisAll,ds) = generateSensibleSubsamples([(2,1),(1,2)])
print(&quot;$experiments\n&quot;)
print(&quot;$paulisAll\n&quot;)</code></pre><pre><code class="language-none">Any[Any[(2, 1), (1, 1)], Any[(1, 3), (2, 2)]]
Any[Any[[[0, 0, 0, 0], [1, 1, 0, 1], [1, 0, 1, 1], [0, 1, 1, 0]], [[0, 0], [0, 1]]], Any[[[0, 0], [1, 1]], [[0, 0, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 0, 1]]]]</code></pre><p>The Experiment numbers are defined like this:</p><pre><code class="language-none">potentialSingles = [
                    [[0,0],[0,1]], # IX
                    [[0,0],[1,0]], # IY
                    [[0,0],[1,1]], # IZ
                    ]


all2QlMuBs =  [  [[0,0,0,0],[1,1,0,1],[1,0,1,1],[0,1,1,0]], #II ZX YZ XY
                 [[0,0,0,0],[1,1,1,0],[0,1,1,1],[1,0,0,1]], #II ZY XZ YX
                 [[0,0,0,0],[0,0,0,1],[0,1,0,0],[0,1,0,1]], #II IX XI XX
                 [[0,0,0,0],[0,0,1,0],[1,0,0,0],[1,0,1,0]], #II IY YI YY
                 [[0,0,0,0],[0,0,1,1],[1,1,0,0],[1,1,1,1]]] #II IZ ZI ZZ</code></pre><p><strong>Returns</strong></p><p>The following tuple (chosenExperiments, chosenPaulis, ds), where</p><ul><li>chosenExperiments is a list of experiment list, where each experiment list contains a tuple of qubit size and experiment number.</li><li>chosenPaulis are the Paulis that will be generated by each tuple in an experiment list (using the 01-&gt;X 10-&gt;Y 11-&gt;Z mapping) </li><li>ds is just a convenient bit-array of offsets of 2*noOfQubits, used in working out offsets for the decoder.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L27-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="getCircuit" href="#getCircuit"><code>getCircuit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>getCircuit(experiment,noOfGates)</p><p>##Arguments 	experiment: a list of tuples (such as that obtained from generateSensibleSubsamples) 	noOfGates: the number of Paulis we want in the middle (to twirl)</p><p>Generates a qiskit circuit that implements the experiment passed in (e.g [(2,1) (2,2)] will generate a cricuit that uses two 2 qubit MUBS at the beginning and end (1 and 2 respectively) and then performs a Pauli Twirl in the middle). The circuits are self-inverting.</p><p>Appropriate barriers are inserted.</p><p>##Example</p><pre><code class="language-none">(experiments,paulisAll,ds) = generateSensibleSubsamples([(2,1),(1,2)]) # Get some experiments
circuit = getCircuit(experiments[1],12) # twelve pauli twirl circuit.
qiskit.execute(circuit,qiskit.Aer.get_backend(&quot;qasm_simulator&quot;),shots=100).result().get_counts() # noisless simulator.
circuit.draw() # Will draw the circuit</code></pre><p><strong>Returns</strong></p><p>the qiskit circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L402-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="doASeries" href="#doASeries"><code>doASeries</code></a> — <span class="docstring-category">Function</span></header><section><div><p>doASeries(experiment,lengths,sequences,shots,noise_mode)</p><p><strong>Arguments</strong></p><pre><code class="language-none">experiment - the experiment to perform (see getCircuit for detailed explanation)
lengths - a list of the lengths to perform the experiment on.
sequences - the number of randomised sequences to perform at each length.
shots - the number of measurements of each sequences
noise-model - the noise model you want passed to the &#39;Aer&#39; simulator.</code></pre><p>A convenience function to simulate the basic information gathering algorithm. We assume a an Aer simulator, and you supply the noise model. For edifferent simulators or to run on a real device you will have to re-implement this function, probably just change the execute line.</p><p><strong>Returns</strong></p><pre><code class="language-none">a list of the a list of the results of each sequence.(ordered by the same way as lengths).</code></pre><p>Note on a real device you probably want to randomise the order that different lengths are called i.e. don&#39;t do all the short ones, slightly longer and then longer ones in a row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L445-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="getCounts" href="#getCounts"><code>getCounts</code></a> — <span class="docstring-category">Function</span></header><section><div><p>getCounts(results,lengths,noOfQubtis)</p><p>Convenience funciton that takes the results from doASeries and consolidates the counts accross different sequences i.e. if we have 10 sequences at lengths 10,20 and 40, groups all the sequences at length 10 together, the seqeunces at length 20 ... etc. It then transforms into a probability vector (i.e. the vector for each length by the total number of counts).</p><p>NOTE: we assume that the machine is able to handle a vector of size 2^noOfQubits</p><p><strong>Returns</strong></p><pre><code class="language-none">A list of probability vectors, one for each length.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L476-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="extractEigenvalues" href="#extractEigenvalues"><code>extractEigenvalues</code></a> — <span class="docstring-category">Function</span></header><section><div><p>extractEigenvalues(counts,lengths)</p><p>Uses the functionality of Juqst - quantumNoise algorithms to extract the eigenvalues from a vector of counts. For documentation on fitTheFidelities, see rharper2/Juqst.jl on gitHub. To see how the counts should look see getCounts or the example workbooks.</p><p><strong>Returns</strong></p><pre><code class="language-none">the Eigenvalues for the supplied probability vector.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L504-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="generateEigenvalues" href="#generateEigenvalues"><code>generateEigenvalues</code></a> — <span class="docstring-category">Function</span></header><section><div><p>generateEigenvalues(stabs)</p><p><strong>Arguments</strong></p><pre><code class="language-none">stabs - a list of the Paulis used in the experiment, this can be obtained from the generateSensibleSubsamples function.</code></pre><p>Uses a recursive algorithm to work out which global eigenvalues will be learnt through the supplied Paulis/experiment. You can use PEEL.fidelityLabels(ix-1) to see the Pauli representation of these eigenvalues. Note the need to subtract 1, to mvoe from Julia 1 index to a 0 index label (i.e. in Julia II...I is 1, whereas fidelityLabels expects this to be 0).</p><p><strong>Returns</strong></p><pre><code class="language-none">a list of eigenvalues (Julia 1 indexed).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L542-L553">source</a></section></article><h2 id="More-down-in-the-weeds"><a class="docs-heading-anchor" href="#More-down-in-the-weeds">More down in the weeds</a><a id="More-down-in-the-weeds-1"></a><a class="docs-heading-anchor-permalink" href="#More-down-in-the-weeds" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="addCircuit" href="#addCircuit"><code>addCircuit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>addCircuit(circuit,experiment<em>type,qubits</em>id)</p><p><strong>Arguments</strong></p><p>circuit - the qiskit circuit we will add gates to.    experiment-type: (Integer,Integer) - the stabilizer group we wont to generate (see below)    qubits_id: Array of Int - the &#39;number&#39; of the qubits the circuit is to be on.</p><p>The stabilizer circuits vary depending on the experiment-type. This is a tuple, the first number indicating the number of  qubits (currently 1 or 2), the second which experiment currently 1:3 for single qubits and 1:5 for two qubits.</p><p>The qubits_id will be used to work out which qubits in the circuit to use. They are &quot;JULIA INDEXED&quot;.</p><p>The qubits are identified via the circuit <code>qubits = circuit.qubits</code>. But because of the way PyCall works, they will be  in a 1 indexed array. e.g. qiskitits qubit_0 will be qubits[1].</p><p>Therefore if you want the circuit to be on qubits 0 and 1, you pass in [1,2] into qubits_id.</p><p>The circuits that will be added will generate the following for two qubits its:</p><ol><li>[[0,0,0,0],[1,1,0,1],[1,0,1,1],[0,1,1,0]], #II ZX YZ XY</li><li>[[0,0,0,0],[1,1,1,0],[0,1,1,1],[1,0,0,1]], #II ZY XZ YX</li><li>[[0,0,0,0],[0,0,0,1],[0,1,0,0],[0,1,0,1]], #II IX XI XX</li><li>[[0,0,0,0],[0,0,1,0],[1,0,0,0],[1,0,1,0]], #II IY YI YY</li><li>[[0,0,0,0],[0,0,1,1],[1,1,0,0],[1,1,1,1]]] #II IZ ZI ZZ</li></ol><p>For one qubit its</p><ol><li>[[0,0],[0,1]], # IX</li><li>[[0,0],[1,0]], # IY</li><li>[[0,0],[1,1]], # IZ</li></ol><p><strong>Returns nothing</strong></p><p>The qiskit circuit will have had the gates added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L107-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="addReverseCircuit" href="#addReverseCircuit"><code>addReverseCircuit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>addReverseCircuit(circuit,experiment<em>type,qubits</em>id)</p><p><strong>Arguments</strong></p><p>circuit - the qiskit circuit we will add gates to.    experiment-type: (Integer,Integer) - the stabilizer group we wont to generate (see below)    qubits_id: Array of Int - the &#39;number&#39; of the qubits the circuit is to be on.</p><p>Effectively this &#39;reverses&#39; the circuit added by addCircuit. </p><p>e.g. </p><pre><code class="language-none">addCircuit(my_circuit,(2,1),[1,2])
addReverseCircuit(my_circuit,(2,1),[1,2,])</code></pre><p>Will create a &#39;nothing&#39; circuit i.e. self inverting.</p><p>The stabilizer circuits vary depending on the experiment-type. This is a tuple, the first number indicating the number of  qubits (currently 1 or 2), the second which experiment currently 1:3 for single qubits and 1:5 for two qubits.</p><p>The qubits_id will be used to work out which qubits in the circuit to use. They are &quot;JULIA INDEXED&quot;.</p><p>The qubits are identified via the circuit <code>qubits = circuit.qubits</code>. But because of the way PyCall works, they will be  in a 1 indexed array. e.g. qiskitits qubit_0 will be qubits[1].</p><p>Therefore if you want the circuit to be on qubits 0 and 1, you pass in [1,2] into qubits_id.</p><p>The circuits that will be added will generate the following for two qubits its:</p><ol><li>[[0,0,0,0],[1,1,0,1],[1,0,1,1],[0,1,1,0]], #II ZX YZ XY</li><li>[[0,0,0,0],[1,1,1,0],[0,1,1,1],[1,0,0,1]], #II ZY XZ YX</li><li>[[0,0,0,0],[0,0,0,1],[0,1,0,0],[0,1,0,1]], #II IX XI XX</li><li>[[0,0,0,0],[0,0,1,0],[1,0,0,0],[1,0,1,0]], #II IY YI YY</li><li>[[0,0,0,0],[0,0,1,1],[1,1,0,0],[1,1,1,1]]] #II IZ ZI ZZ</li></ol><p>For one qubit its</p><ol><li>[[0,0],[0,1]], # IX</li><li>[[0,0],[1,0]], # IY</li><li>[[0,0],[1,1]], # IZ</li></ol><p><strong>Returns nothing</strong></p><p>The qiskit circuit will have had the gates added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L197-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="setUpExperiment" href="#setUpExperiment"><code>setUpExperiment</code></a> — <span class="docstring-category">Function</span></header><section><div><p>setUpExperiment(experiment,circuit;reverse=false)</p><p><strong>Arguments</strong></p><pre><code class="language-none">experiment: List of tuples - the stabilizers to be extracted
circuit: circuit to be done
reverse: apply or removing? Boolean.</code></pre><p>Cycles through the experiment applying the correct gates in the circuit. The experiment is set up as a list of tuples (q<em>no,exp</em>no), representing the number of qubits (currently 1 or 2) and the type of experiment.</p><p>For example [(1,3),(2,1),(2,3)] would be a 5 qubit experiment.</p><ul><li>The 1 qubit experiment 3 would be applied to the first qubit.</li><li>The 2 qubit experiment 1 would be applied to the second and third qubits</li><li>The 2 qubit experiment 3 would be applied to the fourth and fifth qubits.</li></ul><p><strong>Returns</strong></p><p>Nothing, but amends the supplied circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L322-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="genPTwirl" href="#genPTwirl"><code>genPTwirl</code></a> — <span class="docstring-category">Function</span></header><section><div><p>genPTwirl(circuit,len,qubit_id)</p><p>generates a Pauli twirl on the circuit consisting of len gates + inversion gate. On qubit_id</p><p>##Arguments 	circuit - the qiskit circuit to alter 	len - an integer representing the number of gates in the twirl 	qubit_id - an integer representing the qubit. Index from 1 (Julia), the qubit register is retrieved from circuit and is not needed.</p><p><strong>Returns</strong></p><pre><code class="language-none">Nothing - the circuit is altered.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L369-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="getStabilizerForExperiment" href="#getStabilizerForExperiment"><code>getStabilizerForExperiment</code></a> — <span class="docstring-category">Function</span></header><section><div><p>getStabiliserForExperiment(experiment)</p><p>For a given experiment (see generateSensibleSubsamples)  returns the Paulis (in bit form) that are accessed via the experiment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/e76a9ad507ce2908ac5c9766ef5902b00a868d75/localPeelFunctions.jl#L559-L563">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Scalable Estimation Documentation</a><a class="docs-footer-nextpage" href="../peel/">Peel.jl Documentation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 July 2020 12:35">Monday 6 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
