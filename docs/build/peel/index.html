<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Main functions · Scalable Estimation Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Scalable Estimation Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Code</span><ul><li class="is-active"><a class="tocitem" href>Main functions</a><ul class="internal"><li><a class="tocitem" href="#Main-functions"><span>Main functions</span></a></li><li><a class="tocitem" href="#Useful-functions"><span>Useful functions</span></a></li><li><a class="tocitem" href="#Manipulation-of-probability-vectors"><span>Manipulation of probability vectors</span></a></li></ul></li><li><a class="tocitem" href="../localPeel/">Local stabiliser functions</a></li></ul></li><li><a class="tocitem" href="../example/">Example Workbooks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Code</a></li><li class="is-active"><a href>Main functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Main functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rharper2/sparsePauliReconstruction/blob/master/docs/src/peel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Peel.jl-Documentation"><a class="docs-heading-anchor" href="#Peel.jl-Documentation">Peel.jl Documentation</a><a id="Peel.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Peel.jl-Documentation" title="Permalink"></a></h1><h2 id="Main-functions"><a class="docs-heading-anchor" href="#Main-functions">Main functions</a><a id="Main-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.checkAndExtractSingleton" href="#Main.PEEL.checkAndExtractSingleton"><code>Main.PEEL.checkAndExtractSingleton</code></a> — <span class="docstring-category">Function</span></header><section><div><p>checkAndExtractSingleton(indexes,BITS;cutoff=0.000002)</p><p><strong>Arguments</strong></p><pre><code class="language-none">indexes: A list of arrays, being the bins and their offsets.
Bits: the number of bits (being 2*qubits)
cutoff: what the entropy has to be less than</code></pre><p>Checks the &#39;entropy&#39; in the bin (ie sum of the square of the fluctations around the mean of the abs value)/BITS If it is less than the cutoff admits it as a singleton. Extracts the Pauli (using majority vote if given multiple samples)</p><ul><li>Note if you wanted to implement the &quot;Error Correcting Code in the offsets&quot; as described in the appendix of the paper then this funciton would be different.</li></ul><p><strong>Returns</strong></p><pre><code class="language-none">A tuple of: (found,index, value), where found is boolean, the index is an integer and value is float (between 0 and 1).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L317-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.peelBack" href="#Main.PEEL.peelBack"><code>Main.PEEL.peelBack</code></a> — <span class="docstring-category">Function</span></header><section><div><p>peelBack(listOfX,listOfPs,singletonBits,singletonValue,found,ds,mappings)</p><p><strong>Arguments</strong></p><pre><code class="language-none">listOfX - the bins and their offsets &lt;- this gets modified
listOfPs - the stabiliser groups used to create the bins (see generateFromPVecSamples4N)
singletonBits - the bit index of the Pauli to peel back
singletonVlaue - the value of the Pauli to peel back
found - a Dict of Pauli bitstrings that have been found and their value
ds - the offsets used.
mappings - an optional mapping of qubit-&gt;qubit.</code></pre><p>Peel back algorithm tailored for noise version.</p><p>Check if we have already found the supplied Pauli (is it in found?)</p><ul><li>If so check if the value we think we have found is greater than the previous sample<ul><li>If not, then just return - we had already found it, and the noise has just confused us!</li><li>If yes, then the one we found was probably wrong and a result of the noise, just update the value.</li></ul></li></ul><p><em>[Query this logic, it seems to work but perhaps, we may want to update the bins with the difference.]</em></p><ul><li>Otherwise (i.e. we hadn&#39;t found it before.)<ul><li>Get the index of that Pauli into each of the other bin sets</li><li>And add or subtract (depending on relevant offset) the supplied value of the Pauli</li><li>Update found by adding in this Pauli and the value.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L370-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.generateFromPVecSamples4N" href="#Main.PEEL.generateFromPVecSamples4N"><code>Main.PEEL.generateFromPVecSamples4N</code></a> — <span class="docstring-category">Function</span></header><section><div><p>generateFromPVecSamples4N(pvec,d=[],dictMapping)</p><p><strong>Arguments</strong></p><pre><code class="language-none">pvec The list of Paulis which are used in our experiment. Given as an array of stabilisers (see example)
d The offset, this is the binary string &#39;hashed&#39; into the Paulis given by pvec.
map an optional dictionary mapping qubits to other qubits.</code></pre><p>Generates the fidelities we are going to sample from for a given offset  vector (d).</p><p>By way of example, if we supplied as a pvec</p><pre><code class="language-none">[[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0]]
</code></pre><p>Then we would get 0,7,9 and 14.</p><p>If we also suplied a d, [1 0 0 0], then we get 8, 15, 1 6</p><p>A pvec as </p><pre><code class="language-none"> [[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0]]
 [[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0]]</code></pre><p>Would give us 0, 7, 9, 14, 112, 119, 121, 126, 144, 151, 153, 158, 224, 231, 233, 238</p><p><strong>Returns</strong></p><p>Array{Int64,1} with the relevant fidelity indexes. (zero indexed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L221-L256">source</a></section></article><h2 id="Useful-functions"><a class="docs-heading-anchor" href="#Useful-functions">Useful functions</a><a id="Useful-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.fourPattern-Tuple{Any}" href="#Main.PEEL.fourPattern-Tuple{Any}"><code>Main.PEEL.fourPattern</code></a> — <span class="docstring-category">Method</span></header><section><div><p>fourPattern(p)</p><p><strong>Arguments</strong></p><pre><code class="language-none">p::Array{Array{Array{Int64,1},1},1} represents a series of commuting two qubit paulis.</code></pre><p>Given a MUB works out what binary string will go in what bin This takes a 4 bit (two Pauli) set of commuting Paulis, eg.</p><pre><code class="language-none">1-element Array{Array{Array{Int64,1},1},1}:
 [[0, 0, 0, 0], [1, 0, 1, 1], [0, 1, 1, 0], [1, 1, 0, 1]]</code></pre><p>And then returns the Array that shows what bin each of the 16 two qubit Paulis go into e.g.</p><pre><code class="language-none">[[[&quot;0000&quot;, &quot;0111&quot;, &quot;1001&quot;, &quot;1110&quot;], [&quot;0001&quot;, &quot;0110&quot;, &quot;1000&quot;, &quot;1111&quot;], [&quot;0011&quot;, &quot;0100&quot;, &quot;1010&quot;, &quot;1101&quot;], [&quot;0010&quot;, &quot;0101&quot;, &quot;1011&quot;, &quot;1100&quot;]]]</code></pre><p>Which tells us e.g. that &quot;1001&quot; goes into bin 0 and &quot;1101&quot; goes into bin 2.</p><p><strong>Returns</strong></p><pre><code class="language-none">an Array, containing a single array of 4 vectors each of size 4 --- splitting all 16 Paulis (rep as binary strings) into 4 bins.</code></pre><p>If you want to think of this as a hashing function, it shows how to take 4 bits -&gt; 2 bits using the supplied pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L33-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.twoPattern-Tuple{Any}" href="#Main.PEEL.twoPattern-Tuple{Any}"><code>Main.PEEL.twoPattern</code></a> — <span class="docstring-category">Method</span></header><section><div><p>twoPattern(p)</p><p><strong>Arguments</strong></p><pre><code class="language-none"> p Array{Array{Int64,1},1} represents a series of commuting two qubit paulis.</code></pre><p>Given a MUB works out what binary string will go in what bin This takes a 2 bit (one Pauli) set of commuting Paulis, eg.</p><pre><code class="language-none">1-element Array{Array{Array{Int64,1},1},1}:
 [0, 0], [1, 1]</code></pre><p>And then returns a two element Array that shows what bin each of the 16 two qubit Paulis go into e.g.</p><pre><code class="language-none">[&quot;00&quot;, &quot;11&quot;]
[&quot;01&quot;, &quot;10&quot;]</code></pre><p>Which tells us e.g. that &quot;11&quot; goes into bin 0 and &quot;01&quot; goes into bin 2.</p><p><strong>Returns</strong></p><pre><code class="language-none">an Array, containing an array of 2 vectors each of size 2 --- splitting all 4 Paulis (rep as binary strings) into 2 bins.</code></pre><p>If you want to think of this as a hashing function, it shows how to take 2 bits -&gt; 1 bits using the supplied pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L70-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.getIndexOf" href="#Main.PEEL.getIndexOf"><code>Main.PEEL.getIndexOf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>getIndexOf(hadamardMap,no,dictMap=Dict())</p><p><strong>Arguments</strong></p><pre><code class="language-none">hadamardMap: An array of hashing bins (see later)
no: Integer  the index of the Pauli we want to know which bin it gotes into 
dictMap: Dictionary optional mapping eg qubit 2-&gt;qubit 4.</code></pre><p>Given a map (constructed from fourPattern and twoPattern), this will  split the qubits up into the pairs/singles identified by the map and  then determine the hash destingation of a particular Pauli, i.e. which bin it goes into.  The optional dictMapping, allows us to map qubits to different qubits. This might be   relevant for different topologies. E.g. we might want the pair to span qubits 1 and 14, rather  than 1 and 2, so we would map 2 onto 14. There should be examples later.</p><p><strong>NOTE</strong> because we use the least significant (rh) qubit - there is a subte reversal of bits. See example.</p><p><strong>Example</strong></p><p>The hadamard Map for a six qubit system might look like this</p><pre><code class="language-none">4-element Array{Any,1}:
 [[&quot;00&quot;, &quot;10&quot;], [&quot;01&quot;, &quot;11&quot;]]
 [[&quot;0000&quot;, &quot;0110&quot;, &quot;1101&quot;, &quot;1011&quot;], [&quot;1100&quot;, &quot;1010&quot;, &quot;0001&quot;, &quot;0111&quot;], [&quot;1000&quot;, &quot;1110&quot;, &quot;0101&quot;, &quot;0011&quot;], [&quot;0100&quot;, &quot;0010&quot;, &quot;1001&quot;, &quot;1111&quot;]]
 [[&quot;0000&quot;, &quot;1110&quot;, &quot;1001&quot;, &quot;0111&quot;], [&quot;1100&quot;, &quot;0010&quot;, &quot;0101&quot;, &quot;1011&quot;], [&quot;0100&quot;, &quot;1010&quot;, &quot;1101&quot;, &quot;0011&quot;], [&quot;1000&quot;, &quot;0110&quot;, &quot;0001&quot;, &quot;1111&quot;]]
 [[&quot;00&quot;, &quot;01&quot;], [&quot;10&quot;, &quot;11&quot;]]</code></pre><p>Where we have used twoPattern for qubits 0 and 5 and fourPattern for qubits 1&amp;2 and 3&amp;4</p><p>getIndexOf(patternAbove, 23), would then return 6.</p><p>Because 23 = &quot;000000010111&quot;  Then we map the bins as   00-&gt; reversed to 00 -&gt; bin 0 -&gt; 0  0000 -&gt; reversed to 0000 -&gt;  bin 0 -&gt; 00  0101 -&gt; reversed to 1010 -&gt;  bin 2 -&gt; 10  11 -&gt;  reversed to 11 -&gt; bin 1 -&gt; 01</p><p>Therefore the index is 0 00 10 01 = 5, as we one index we return 6.</p><p><strong>Returns</strong></p><p>Index of bin (1 indexed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L104-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.constructTheKeyIndexMUB" href="#Main.PEEL.constructTheKeyIndexMUB"><code>Main.PEEL.constructTheKeyIndexMUB</code></a> — <span class="docstring-category">Function</span></header><section><div><p>constructTheKeyIndexMUB(indx,listOfPs,map=[])</p><p><strong>Arguments</strong></p><pre><code class="language-none">indx The index of a Pauli, we want to ascertain which bins that Pauli was hashed into.
listOfPs The used to sample/bin the Paulis
map A map of qubit substitutions e.g mapping qubit 2 to 14</code></pre><p>Given a Paulis to test, returns the index into all the bins that Paulis is hashed into  (it is assumed we have a number a sub-sampling groups). Basically just iterates over them. If we supply a map, it should be an array of maps, one for each different set of n-qubit MUBS supplied.</p><p>It uses getIndexOf to do all the heavy lifting, the documentation for that function  provides an example of the type of map it requires, this is an array of these maps.</p><p>Returns and array of offsets representing the index the Pauli gets hashed to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L193-L211">source</a></section></article><h2 id="Manipulation-of-probability-vectors"><a class="docs-heading-anchor" href="#Manipulation-of-probability-vectors">Manipulation of probability vectors</a><a id="Manipulation-of-probability-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulation-of-probability-vectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.simplexUp" href="#Main.PEEL.simplexUp"><code>Main.PEEL.simplexUp</code></a> — <span class="docstring-category">Function</span></header><section><div><p>simplexUp(n)</p><p><strong>Arguments</strong></p><p><code>n (Int)</code>  = number to project onto </p><p>Projects onto the n-simplex. i.e. returns n numbers such that the sum of them is 1.</p><p><strong>Returns</strong></p><p>vector of n-numbers that add up to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L495-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.PEEL.generatePauliFromClifford" href="#Main.PEEL.generatePauliFromClifford"><code>Main.PEEL.generatePauliFromClifford</code></a> — <span class="docstring-category">Function</span></header><section><div><p>generatePauliFromClifford(n)</p><p><strong>Arguments</strong></p><pre><code class="language-none">cliffordPs: Array{Float64,1}</code></pre><p>Splits the &quot;Clifford average&quot; which we recover from the protocol in Efficient Learning of quantum Noise arXiv:1907.13022. into  a fake Pauli distribution, that would average to the same Clifford average. We are going to use this to test the algorithm.</p><p>We do this by realising that each member of our <span>$2^n$</span> distribution was in fact an average of certain Paulis. We work out how many Paulis went into the distribution (<code>splitUp(n)</code>) and then project the number onto an appropriate simplex (<code>simplexUp</code>).</p><p>This allows us to recreate a <span>$4^n$</span> distribution that would average down to the supplied distribution. Of course there is a random  element with the projection up stage, but it is <em>experimentally</em> inspired if the original averaged protocol came from an experiment.</p><p><strong>Returns</strong></p><p>A Pauli probability distribution that result in the supplied probability distribution if they were the errors caused by the  avarged noise in the machine and that machine was subject to single qubit Clifford twirls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/sparsePauliReconstruction/blob/f4c1c9def848952f1b7399d11e5bb0c4925e481d/peel.jl#L605-L624">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../localPeel/">Local stabiliser functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 16 July 2020 14:43">Thursday 16 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
